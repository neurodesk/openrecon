

import json
import jsonschema
import base64
import os

def validateJson(jsonFilePath, schemaFilePath):
    try:
        # Load the JSON data from the file
        with open(jsonFilePath, 'r') as jsonFile:
            jsonData = json.load(jsonFile)

        # Load the JSON schema from the file
        with open(schemaFilePath, 'r') as schemaFile:
            schemaData = json.load(schemaFile)

        # Create a JSON Schema validator
        validator = jsonschema.Draft7Validator(schemaData)

        # Validate the JSON data against the schema
        errors = list(validator.iter_errors(jsonData))

        if not errors:
            print("JSON is valid against the schema.")
            return True
        else:
            print("JSON is not valid against the schema. Errors:")
            for error in errors:
                print(error)
            return False
    
    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == '__main__':
    # Validate JSON file against OpenRecon schema and write Dockerfile
    jsonFilePath    = 'OpenReconLabel.json'
    schemaFilePath  = '../OpenReconSchema_1.1.0.json'
    dockerfilePath  = 'OpenRecon.dockerfile'
    # Check if DOCKER_IMAGE_TO_USE is set (from build.sh local image check)
    dockerImageToUse = os.getenv('DOCKER_IMAGE_TO_USE')
    baseDockerImage = dockerImageToUse if dockerImageToUse else os.getenv('baseDockerImage')
    useLocalImage = os.getenv('USE_LOCAL_IMAGE', 'false').lower() == 'true'

    # Write Dockerfile
    if validateJson(jsonFilePath, schemaFilePath):
        with open(jsonFilePath, 'r') as jsonFile:
            jsonData = json.load(jsonFile)
        jsonString = json.dumps(jsonData, indent=2)
        encodedJson = base64.b64encode(jsonString.encode('utf-8')).decode('utf-8')

        with open(dockerfilePath, 'w') as file:
            labelName = 'com.siemens-healthineers.magneticresonance.openrecon.metadata:1.1.0'
            labelStr = 'LABEL "' + labelName + '"="' + encodedJson + '"'

            file.writelines('FROM ' + baseDockerImage)
            file.writelines('\n' + labelStr)
            file.writelines('\n')
            file.writelines('CMD [ "/bin/bash", "-c", "/usr/sbin/ldconfig && exec python3 /opt/code/python-ismrmrd-server/main.py -v -H=0.0.0.0 -p=9002 -l=/tmp/python-ismrmrd-server.log"]')
        print('Wrote Dockerfile:', os.path.abspath(dockerfilePath))
    else:
        raise Exception('Not writing Dockerfile because JSON is not valid')

    # Build Docker image, save to a .tar file, and package into a .zip file for OpenRecon
    # The documentation must be a valid PDF!
    # README.pdf is autogenerated from README.md, but if it should be overwritten with a dedicated docs.pdf thats's possible
    if os.path.isfile('docs.pdf'):
        docsFile = 'docs.pdf'
    else:
        docsFile = 'README.pdf'

    # Filename must match information contained in the JSON
    version = jsonData['general']['version']
    vendor  = jsonData['general']['vendor']
    name    = jsonData['general']['name']['en']

    # Check documentation file exists
    if not os.path.isfile(docsFile):
        raise Exception('Could not find documentation file: ' + docsFile)

    # Check 7-zip exists
    import shutil
    zipExe = shutil.which('7z')
    
    if zipExe is None:
        raise Exception('Could not find 7-Zip executable in PATH. Please download and install 7-Zip')

    dockerImagename = ('OpenRecon_' + vendor + '_' + name + ':' +  'V' + version).lower()
    baseFilename    =  'OpenRecon_' + vendor + '_' + name +       '_V' + version

    import subprocess
    import shutil

    try:
        import time
        start_time = time.time()
        
        # Check CUDA version in base image before building
        print('=' * 70)
        print('PRE-BUILD: Checking CUDA version in base image')
        print('=' * 70)
        print(f'Base image: {baseDockerImage}')
        
        # Import and run CUDA version check on base image
        from checkCudaVersion import checkCudaVersionInContainer
        try:
            checkCudaVersionInContainer(baseDockerImage, maxCudaVersion="11.8")
        except Exception as e:
            print(f'\n‚ùå Base image CUDA version check failed')
            raise
        
        # Build Docker image docker buildx build --platform linux/amd64
        print('=' * 70)
        print('STEP 1/5: Preparing Docker image build')
        print('=' * 70)
        print('Attempting to create Docker image with tag:', dockerImagename, '...')
        if useLocalImage:
            print('Using local base image:', baseDockerImage)
            # Check if base image tar already exists to skip re-saving
            base_image_tar = '.base_image.tar'
            if os.path.exists(base_image_tar):
                # Prompt user whether to reuse or regenerate
                print(f'\n‚ö†Ô∏è  Found existing {base_image_tar}')
                while True:
                    response = input('Do you want to reuse it? (y/n): ').strip().lower()
                    if response in ['y', 'yes']:
                        print(f'‚ö° Reusing existing {base_image_tar} (skip re-save for speed)')
                        break
                    elif response in ['n', 'no']:
                        print(f'üóëÔ∏è  Removing old {base_image_tar}')
                        os.remove(base_image_tar)
                        print(f'üíæ Saving base image to {base_image_tar}... (this may take 2-3 minutes)')
                        subprocess.check_output(['docker', 'save', '-o', base_image_tar, baseDockerImage], stderr=subprocess.STDOUT)
                        print('‚úì Base image saved successfully')
                        break
                    else:
                        print('Please answer "y" or "n"')
            else:
                print(f'üíæ Saving base image to {base_image_tar}... (this may take 2-3 minutes)')
                subprocess.check_output(['docker', 'save', '-o', base_image_tar, baseDockerImage], stderr=subprocess.STDOUT)
                print('‚úì Base image saved successfully')
        else:
            print('Using remote base image:', baseDockerImage)
            base_image_tar = None
        
        # Initialize Docker-in-Docker client
        docker_client_image = "docker:24.0-dind"
        print(f'\nüê≥ Pulling DinD image {docker_client_image}...')
        subprocess.check_output(['docker', 'pull', '--platform', 'linux/amd64', docker_client_image], stderr=subprocess.STDOUT)
        print('‚úì DinD image ready')
        
        # Prepare script to load base image if needed
        load_image_cmd = ""
        if useLocalImage and base_image_tar:
            load_image_cmd = f"""
        echo "üì¶ Loading base image from tar file... (this may take 2-3 minutes)"
        docker load -i /workspace/{base_image_tar}
        echo "‚úì Base image loaded into DinD daemon"
        """
        
        print('\n' + '=' * 70)
        print('STEP 2/5: Building Docker image')
        print('=' * 70)
        
        # Create a unique Docker volume name for this build
        import uuid
        volume_name = f"docker-build-{uuid.uuid4().hex[:8]}"
        print(f'üìÅ Creating temporary Docker volume: {volume_name}')
        
        # Create Docker volume
        subprocess.check_output(['docker', 'volume', 'create', volume_name], stderr=subprocess.STDOUT)
        
        # Run Docker build inside Docker-in-Docker container with proper daemon startup
        docker_build_script = f"""
        set -e
        echo "üöÄ Starting Docker daemon..."
        # Start Docker daemon in background - use default /var/lib/docker location
        dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375 &
        # Wait for Docker daemon to start
        timeout=60
        while ! DOCKER_HOST=unix:///var/run/docker.sock docker version >/dev/null 2>&1; do
            sleep 2
            timeout=$((timeout - 2))
            if [ $timeout -le 0 ]; then
                echo "‚ùå Docker daemon failed to start"
                exit 1
            fi
        done
        echo "‚úì Docker daemon is ready"
        # Set Docker host for all subsequent commands
        export DOCKER_HOST=unix:///var/run/docker.sock
        {load_image_cmd}
        echo "üî® Building Docker image (with layer caching)..."
        # Build the image (removed --no-cache for speed)
        docker buildx build --platform linux/amd64 --progress=plain -t {dockerImagename} -f {dockerfilePath} ./
        echo "‚úì Docker image built successfully"
        
        echo "üíæ Saving image to tar file... (this may take 2-3 minutes)"
        # Save the image
        docker save -o /workspace/{baseFilename}.tar {dockerImagename}
        # Ensure the tar file has proper permissions
        chmod 644 /workspace/{baseFilename}.tar
        echo "‚úì Image saved to {baseFilename}.tar"
        """
        print('Running build in DinD container...\n')
        
        # Start the Docker process
        process = subprocess.Popen([
            'docker', 'run', '--rm', '--privileged',
            '--platform', 'linux/amd64',
            '-v', f"{volume_name}:/var/lib/docker",
            '-v', f"{os.getcwd()}:/workspace",
            '-w', '/workspace',
            docker_client_image,
            'sh', '-c', docker_build_script
        ], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, bufsize=1, universal_newlines=True)
        
        # Monitor output and track tar file creation with progress bar
        output_lines = []
        tar_file_path = os.path.join(os.getcwd(), f"{baseFilename}.tar")
        
        # Initialize shared state variables before try block
        monitoring_tar = False
        pbar = None
        monitor_thread = None
        
        try:
            import threading
            
            def monitor_tar_file():
                """Monitor the growing tar file and update progress bar"""
                last_size = 0
                while monitoring_tar:
                    if os.path.exists(tar_file_path):
                        try:
                            current_size = os.path.getsize(tar_file_path)
                            if current_size > last_size and pbar:
                                pbar.update(current_size - last_size)
                                last_size = current_size
                        except (OSError, IOError):
                            pass
                    time.sleep(5)  # Reduced polling frequency from 0.2s to 0.5s
            
            for line in process.stdout:
                output_lines.append(line)
                print(line, end='')
                
                # Start monitoring when we see the save message
                if "üíæ Saving image to tar file" in line and not monitoring_tar:
                    monitoring_tar = True
                    try:
                        from tqdm import tqdm
                        # Estimate size - actual size will vary but this gives a progress indicator
                        # Use 20GB as a reasonable estimate for most images
                        estimated_size = 20 * 1024 * 1024 * 1024
                        pbar = tqdm(total=estimated_size, desc="Saving image", unit='B', 
                                   unit_scale=True, unit_divisor=1024)
                        monitor_thread = threading.Thread(target=monitor_tar_file, daemon=True)
                        monitor_thread.start()
                    except ImportError:
                        pass  # If tqdm not available, just skip progress bar
                
                # Stop monitoring when save is complete
                if "‚úì Image saved to" in line and monitoring_tar:
                    monitoring_tar = False
                    if pbar:
                        # Update to actual final size
                        if os.path.exists(tar_file_path):
                            final_size = os.path.getsize(tar_file_path)
                            pbar.n = final_size
                            pbar.total = final_size
                        pbar.close()
                        pbar = None
                    if monitor_thread:
                        monitor_thread.join(timeout=1)
            
            process.wait()
            
            if process.returncode != 0:
                raise subprocess.CalledProcessError(process.returncode, process.args, 
                                                   output=''.join(output_lines))
        
        finally:
            # Clean up progress bar if still active
            monitoring_tar = False
            if pbar:
                pbar.close()
            
            # Clean up Docker volume
            print(f'\nüóëÔ∏è  Cleaning up temporary Docker volume: {volume_name}')
            subprocess.run(['docker', 'volume', 'rm', '-f', volume_name], 
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        
        step_time = time.time() - start_time
        print(f'\n‚è±Ô∏è  Build completed in {step_time:.1f} seconds')
        
        print('\n' + '=' * 70)
        print('STEP 3/5: Preparing documentation')
        print('=' * 70)
        # Copy documentation file with appropriate filename
        print(f'üìÑ Copying documentation to {baseFilename}.pdf...')
        try:
            shutil.copy(docsFile, baseFilename + '.pdf')
            print(f'‚úì Documentation copied')
        except IOError as e:
            print(f'‚ùå Error copying documentation: {e}')

        print('\n' + '=' * 70)
        print('STEP 4/5: Creating final package')
        print('=' * 70)
        
        # Check for USB thumb drives (macOS only)
        output_dir = os.getcwd()
        if shutil.which('diskutil'):  # macOS system
            try:
                # Get list of external volumes
                volumes_output = subprocess.check_output(['ls', '/Volumes'], stderr=subprocess.DEVNULL).decode('utf-8')
                volumes = [v.strip() for v in volumes_output.split('\n') if v.strip() and v.strip() != 'Macintosh HD']
                
                # Filter to only removable/external drives
                usb_drives = []
                for vol in volumes:
                    vol_path = os.path.join('/Volumes', vol)
                    try:
                        # Get disk info to check if it's removable
                        disk_info = subprocess.check_output(['diskutil', 'info', vol_path], stderr=subprocess.DEVNULL).decode('utf-8')
                        if 'Removable Media' in disk_info or 'External' in disk_info:
                            # Get available space
                            stat = os.statvfs(vol_path)
                            free_space_gb = (stat.f_bavail * stat.f_frsize) / (1024**3)
                            usb_drives.append((vol, free_space_gb))
                    except:
                        pass
                
                if usb_drives:
                    print('\nüîç Detected USB drive(s):')
                    for i, (vol, free_space_gb) in enumerate(usb_drives, 1):
                        print(f'   {i}. {vol} (Free: {free_space_gb:.1f} GiB)')
                    
                    # If only one USB drive, automatically select it
                    if len(usb_drives) == 1:
                        selected_volume = usb_drives[0][0]
                        output_dir = os.path.join('/Volumes', selected_volume)
                        # Verify we can write to it
                        test_file = os.path.join(output_dir, '.write_test')
                        try:
                            with open(test_file, 'w') as f:
                                f.write('test')
                            os.remove(test_file)
                            print(f'‚úì Automatically selected USB drive: {output_dir}')
                        except:
                            print(f'‚ùå Cannot write to {output_dir}. Saving locally instead.')
                            output_dir = os.getcwd()
                    else:
                        # Multiple USB drives - prompt user to select
                        print('\nüíæ Would you like to save the output directly to a USB drive?')
                        while True:
                            response = input('Enter drive number to save there, or press Enter to save locally: ').strip()
                            if response == '':
                                print('üìÅ Saving to current directory')
                                break
                            try:
                                drive_idx = int(response) - 1
                                if 0 <= drive_idx < len(usb_drives):
                                    selected_volume = usb_drives[drive_idx][0]
                                    output_dir = os.path.join('/Volumes', selected_volume)
                                    # Verify we can write to it
                                    test_file = os.path.join(output_dir, '.write_test')
                                    try:
                                        with open(test_file, 'w') as f:
                                            f.write('test')
                                        os.remove(test_file)
                                        print(f'‚úì Will save to: {output_dir}')
                                        break
                                    except:
                                        print(f'‚ùå Cannot write to {output_dir}. Saving locally instead.')
                                        output_dir = os.getcwd()
                                        break
                                else:
                                    print(f'Please enter a number between 1 and {len(usb_drives)}, or press Enter')
                            except ValueError:
                                print('Please enter a valid number or press Enter')
            except:
                pass  # If any error, just continue with local directory
        
        # Zip into a package (using store mode for speed)
        zip_output_path = os.path.join(output_dir, baseFilename + '.zip')
        print(f'üì¶ Packaging files into {os.path.basename(zip_output_path)}...')
        if output_dir != os.getcwd():
            print(f'   Target: {output_dir}')
        print('   (Using Deflate mode - need for OpenRecon)')
        
        # Get total size for progress calculation
        tar_size = os.path.getsize(baseFilename + '.tar')
        pdf_size = os.path.getsize(baseFilename + '.pdf')
        # Estimate compressed size to be 40% smaller than tar file
        estimated_compressed_size = int(tar_size * 0.6)
        total_size = estimated_compressed_size + pdf_size
        
        # Run 7z with progress monitoring
        try:
            from tqdm import tqdm
            import threading
            
            zip_output_file = zip_output_path
            
            # Remove old zip if exists
            if os.path.exists(zip_output_file):
                os.remove(zip_output_file)
            
            # Progress bar showing file sizes
            pbar = tqdm(total=total_size, desc="Compressing", unit='B', unit_scale=True, unit_divisor=1024)
            
            # Flag to stop monitoring
            stop_monitoring = threading.Event()
            
            def monitor_zip_size():
                """Monitor the growing zip file size"""
                last_size = 0
                while not stop_monitoring.is_set():
                    if os.path.exists(zip_output_file):
                        try:
                            current_size = os.path.getsize(zip_output_file)
                            if current_size > last_size:
                                pbar.update(current_size - last_size)
                                last_size = current_size
                        except (OSError, IOError):
                            pass
                    time.sleep(5)
            
            # Start monitoring thread
            monitor_thread = threading.Thread(target=monitor_zip_size, daemon=True)
            monitor_thread.start()
            
            # Run 7z compression
            process = subprocess.Popen(
                [zipExe, 'a', '-tzip', '-mm=Deflate', zip_output_file, baseFilename + '.tar', baseFilename + '.pdf'],
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT
            )
            
            # Wait for completion
            process.wait()
            
            # Stop monitoring
            stop_monitoring.set()
            monitor_thread.join(timeout=1)
            
            # Update to full size
            if os.path.exists(zip_output_file):
                final_size = os.path.getsize(zip_output_file)
                pbar.n = min(total_size, final_size)
            else:
                pbar.n = total_size
            pbar.refresh()
            pbar.close()
            
            if process.returncode != 0:
                output = process.stdout.read().decode('utf-8') if process.stdout else ''
                raise subprocess.CalledProcessError(process.returncode, process.args, output=output)
                
        except ImportError:
            # Fallback if tqdm is not available
            print('   (Installing tqdm for progress bar...)')
            subprocess.check_call([shutil.which('pip3'), 'install', '--quiet', 'tqdm'])
            # Just run without progress bar this time
            output = subprocess.check_output([zipExe, 'a', '-tzip', '-mm=Deflate', baseFilename + '.zip', baseFilename + '.tar', baseFilename + '.pdf'], stderr=subprocess.STDOUT)
        
        print('‚úì Package created successfully')
        
        print('\n' + '=' * 70)
        print('STEP 5/5: Cleanup')
        print('=' * 70)
        
        # Clean up temporary tar and pdf files
        print('üóëÔ∏è  Cleaning up temporary files...')
        try:
            if os.path.exists(baseFilename + '.tar'):
                os.remove(baseFilename + '.tar')
                print(f'   Removed {baseFilename}.tar')
        except Exception as e:
            print(f'   Warning: Could not remove tar file: {e}')
        
        try:
            if os.path.exists(baseFilename + '.pdf'):
                os.remove(baseFilename + '.pdf')
                print(f'   Removed {baseFilename}.pdf')
        except Exception as e:
            print(f'   Warning: Could not remove pdf file: {e}')
        
        # Optionally keep base_image_tar for next build
        keep_cache = os.getenv('KEEP_CACHE', 'true').lower() == 'true'
        if useLocalImage and base_image_tar and os.path.exists(base_image_tar):
            if keep_cache:
                print(f'üíæ Keeping {base_image_tar} for next build (set KEEP_CACHE=false to remove)')
            else:
                os.remove(base_image_tar)
                print(f'üóëÔ∏è  Removed temporary tar file: {base_image_tar}')
        
        total_time = time.time() - start_time
        print('\n' + '=' * 70)
        print(f'‚úÖ BUILD COMPLETED SUCCESSFULLY in {total_time:.1f} seconds ({total_time/60:.1f} minutes)')
        print('=' * 70)
        print(f'üì¶ Output: {zip_output_path}')
        if os.path.exists(zip_output_path):
            size_bytes = os.path.getsize(zip_output_path)
            size_gb = size_bytes / (1024**3)
            print(f'üìä Size: {size_gb:.2f} GiB')
        print('=' * 70)

    except subprocess.CalledProcessError as e:
        # If the command returns a non-zero exit status, it will raise a CalledProcessError
        print('Command failed with return code:', e.returncode)
        if hasattr(e.output, 'decode'):
            print('Error output:\n' + e.output.decode('utf-8'))
        else:
            print('Error output:\n' + str(e.output))

