

import json
import jsonschema
import base64
import os

# Validate JSON file against OpenRecon schema and write Dockerfile
jsonFilePath    = 'OpenReconLabel.json'
schemaFilePath  = '../OpenReconSchema_1.1.0.json'
dockerfilePath  = 'OpenRecon.dockerfile'
baseDockerImage = os.getenv('baseDockerImage')

def validateJson(jsonFilePath, schemaFilePath):
    try:
        # Load the JSON data from the file
        with open(jsonFilePath, 'r') as jsonFile:
            jsonData = json.load(jsonFile)

        # Load the JSON schema from the file
        with open(schemaFilePath, 'r') as schemaFile:
            schemaData = json.load(schemaFile)

        # Create a JSON Schema validator
        validator = jsonschema.Draft7Validator(schemaData)

        # Validate the JSON data against the schema
        errors = list(validator.iter_errors(jsonData))

        if not errors:
            print("JSON is valid against the schema.")
            return True
        else:
            print("JSON is not valid against the schema. Errors:")
            for error in errors:
                print(error)
            return False
    
    except Exception as e:
        print(f"An error occurred: {e}")

# Write Dockerfile
if validateJson(jsonFilePath, schemaFilePath):
    with open(jsonFilePath, 'r') as jsonFile:
        jsonData = json.load(jsonFile)
    jsonString = json.dumps(jsonData, indent=2)
    encodedJson = base64.b64encode(jsonString.encode('utf-8')).decode('utf-8')

    with open(dockerfilePath, 'w') as file:
        labelName = 'com.siemens-healthineers.magneticresonance.openrecon.metadata:1.1.0'
        labelStr = 'LABEL "' + labelName + '"="' + encodedJson + '"'

        file.writelines('FROM ' + baseDockerImage)
        file.writelines('\n' + labelStr)
        file.writelines('\n')
        file.writelines('CMD [ "python3", "/opt/code/python-ismrmrd-server/main.py", "-v", "-r", "-H=0.0.0.0", "-p=9002", "-l=/tmp/python-ismrmrd-server.log", "-s", "-S=/tmp/share/saved_data"]')
    print('Wrote Dockerfile:', os.path.abspath(dockerfilePath))
else:
    raise Exception('Not writing Dockerfile because JSON is not valid')

# Build Docker image, save to a .tar file, and package into a .zip file for OpenRecon
# The documentation must be a valid PDF!
# README.pdf is autogenerated from README.md, but if it should be overwritten with a dedicated docs.pdf thats's possible
if os.path.isfile('docs.pdf'):
    docsFile = 'docs.pdf'
else:
    docsFile = 'README.pdf'

# Filename must match information contained in the JSON
version = jsonData['general']['version']
vendor  = jsonData['general']['vendor']
name    = jsonData['general']['name']['en']

# Check documentation file exists
if not os.path.isfile(docsFile):
    raise Exception('Could not find documentation file: ' + docsFile)

# Check 7-zip exists
zipExe = '/usr/bin/7z'

if not os.path.isfile(zipExe):
    raise Exception('Could not find 7-Zip executable: ' + zipExe + '\nPlease download and install 7-Zip')

dockerImagename = ('OpenRecon_' + vendor + '_' + name + ':' +  'V' + version).lower()
baseFilename    =  'OpenRecon_' + vendor + '_' + name +       '_V' + version

import subprocess
import shutil

try:
    # Build Docker image docker buildx build --platform linux/amd64
    print('Attempting to create Docker image with tag:', dockerImagename, '...')
    # Initialize Docker-in-Docker client
    docker_client_image = "docker:24.0-dind"
    # Pull the Docker-in-Docker image if not present
    subprocess.check_output(['docker', 'pull', docker_client_image], stderr=subprocess.STDOUT)
    # Run Docker build inside Docker-in-Docker container with proper daemon startup
    docker_build_script = f"""
    set -e
    # Start Docker daemon in background
    dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375 &
    # Wait for Docker daemon to start
    timeout=60
    while ! DOCKER_HOST=unix:///var/run/docker.sock docker version >/dev/null 2>&1; do
        sleep 2
        timeout=$((timeout - 2))
        if [ $timeout -le 0 ]; then
            echo "Docker daemon failed to start"
            exit 1
        fi
    done
    echo "Docker daemon is ready"
    # Set Docker host for all subsequent commands
    export DOCKER_HOST=unix:///var/run/docker.sock
    # Build the image
    docker buildx build --platform linux/amd64 --no-cache --progress=plain -t {dockerImagename} -f {dockerfilePath} ./
    # Save the image
    docker save -o /workspace/{baseFilename}.tar {dockerImagename}
    # Ensure the tar file has proper permissions
    chmod 644 /workspace/{baseFilename}.tar
    """
    output = subprocess.check_output([
        'docker', 'run', '--rm', '--privileged',
        '-v', f"{os.getcwd()}:/workspace",
        '-w', '/workspace',
        docker_client_image,
        'sh', '-c', docker_build_script
    ], stderr=subprocess.STDOUT)  
    print('Docker build and save output:\n' + output.decode('utf-8'))

    # Copy documentation file with appropriate filename
    print('Copying documentation to file with name:', baseFilename + '.pdf', '...')
    try:
        shutil.copy(docsFile, baseFilename + '.pdf')
        print(f'File copied from {docsFile} to {baseFilename}.pdf')
    except IOError as e:
        print(f'An error occurred: {e}')

    # Zip into a package
    print('Packaging files into zip with name:', baseFilename + '.zip', '...')
    output = subprocess.check_output([zipExe, 'a', '-tzip', '-mm=Deflate', baseFilename + '.zip', baseFilename + '.tar', baseFilename + '.pdf'], stderr=subprocess.STDOUT)
    print('Zip packaging output:\n' + output.decode('utf-8'))

except subprocess.CalledProcessError as e:
    # If the command returns a non-zero exit status, it will raise a CalledProcessError
    print('Command failed with return code:', e.returncode)
    print('Error output:\n' + e.output.decode('utf-8'))

