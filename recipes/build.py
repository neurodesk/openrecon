

import json
import jsonschema
import base64
import os

def validateJson(jsonFilePath, schemaFilePath):
    try:
        # Load the JSON data from the file
        with open(jsonFilePath, 'r') as jsonFile:
            jsonData = json.load(jsonFile)

        # Load the JSON schema from the file
        with open(schemaFilePath, 'r') as schemaFile:
            schemaData = json.load(schemaFile)

        # Create a JSON Schema validator
        validator = jsonschema.Draft7Validator(schemaData)

        # Validate the JSON data against the schema
        errors = list(validator.iter_errors(jsonData))

        if not errors:
            print("JSON is valid against the schema.")
            return True
        else:
            print("JSON is not valid against the schema. Errors:")
            for error in errors:
                print(error)
            return False
    
    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == '__main__':
    # Validate JSON file against OpenRecon schema and write Dockerfile
    jsonFilePath    = 'OpenReconLabel.json'
    schemaFilePath  = '../OpenReconSchema_1.1.0.json'
    dockerfilePath  = 'OpenRecon.dockerfile'
    # Check if DOCKER_IMAGE_TO_USE is set (from build.sh local image check)
    dockerImageToUse = os.getenv('DOCKER_IMAGE_TO_USE')
    baseDockerImage = dockerImageToUse if dockerImageToUse else os.getenv('baseDockerImage')
    useLocalImage = os.getenv('USE_LOCAL_IMAGE', 'false').lower() == 'true'

    # Write Dockerfile
    if validateJson(jsonFilePath, schemaFilePath):
        with open(jsonFilePath, 'r') as jsonFile:
            jsonData = json.load(jsonFile)
        jsonString = json.dumps(jsonData, indent=2)
        encodedJson = base64.b64encode(jsonString.encode('utf-8')).decode('utf-8')

        with open(dockerfilePath, 'w') as file:
            labelName = 'com.siemens-healthineers.magneticresonance.openrecon.metadata:1.1.0'
            labelStr = 'LABEL "' + labelName + '"="' + encodedJson + '"'

            file.writelines('FROM ' + baseDockerImage)
            file.writelines('\n' + labelStr)
            file.writelines('\n')
            file.writelines('CMD [ "python3", "/opt/code/python-ismrmrd-server/main.py", "-v", "-r", "-H=0.0.0.0", "-p=9002", "-l=/tmp/python-ismrmrd-server.log", "-s", "-S=/tmp/share/saved_data"]')
        print('Wrote Dockerfile:', os.path.abspath(dockerfilePath))
    else:
        raise Exception('Not writing Dockerfile because JSON is not valid')

    # Build Docker image, save to a .tar file, and package into a .zip file for OpenRecon
    # The documentation must be a valid PDF!
    # README.pdf is autogenerated from README.md, but if it should be overwritten with a dedicated docs.pdf thats's possible
    if os.path.isfile('docs.pdf'):
        docsFile = 'docs.pdf'
    else:
        docsFile = 'README.pdf'

    # Filename must match information contained in the JSON
    version = jsonData['general']['version']
    vendor  = jsonData['general']['vendor']
    name    = jsonData['general']['name']['en']

    # Check documentation file exists
    if not os.path.isfile(docsFile):
        raise Exception('Could not find documentation file: ' + docsFile)

    # Check 7-zip exists
    import shutil
    zipExe = shutil.which('7z')
    
    if zipExe is None:
        raise Exception('Could not find 7-Zip executable in PATH. Please download and install 7-Zip')

    dockerImagename = ('OpenRecon_' + vendor + '_' + name + ':' +  'V' + version).lower()
    baseFilename    =  'OpenRecon_' + vendor + '_' + name +       '_V' + version

    import subprocess
    import shutil

    try:
        import time
        start_time = time.time()
        
        # Build Docker image docker buildx build --platform linux/amd64
        print('=' * 70)
        print('STEP 1/5: Preparing Docker image build')
        print('=' * 70)
        print('Attempting to create Docker image with tag:', dockerImagename, '...')
        if useLocalImage:
            print('Using local base image:', baseDockerImage)
            # Check if base image tar already exists to skip re-saving
            base_image_tar = '.base_image.tar'
            if os.path.exists(base_image_tar):
                # Prompt user whether to reuse or regenerate
                print(f'\n‚ö†Ô∏è  Found existing {base_image_tar}')
                while True:
                    response = input('Do you want to reuse it? (y/n): ').strip().lower()
                    if response in ['y', 'yes']:
                        print(f'‚ö° Reusing existing {base_image_tar} (skip re-save for speed)')
                        break
                    elif response in ['n', 'no']:
                        print(f'üóëÔ∏è  Removing old {base_image_tar}')
                        os.remove(base_image_tar)
                        print(f'üíæ Saving base image to {base_image_tar}... (this may take 2-3 minutes)')
                        subprocess.check_output(['docker', 'save', '-o', base_image_tar, baseDockerImage], stderr=subprocess.STDOUT)
                        print('‚úì Base image saved successfully')
                        break
                    else:
                        print('Please answer "y" or "n"')
            else:
                print(f'üíæ Saving base image to {base_image_tar}... (this may take 2-3 minutes)')
                subprocess.check_output(['docker', 'save', '-o', base_image_tar, baseDockerImage], stderr=subprocess.STDOUT)
                print('‚úì Base image saved successfully')
        else:
            print('Using remote base image:', baseDockerImage)
            base_image_tar = None
        
        # Initialize Docker-in-Docker client
        docker_client_image = "docker:24.0-dind"
        print(f'\nüê≥ Pulling DinD image {docker_client_image}...')
        subprocess.check_output(['docker', 'pull', '--platform', 'linux/amd64', docker_client_image], stderr=subprocess.STDOUT)
        print('‚úì DinD image ready')
        
        # Prepare script to load base image if needed
        load_image_cmd = ""
        if useLocalImage and base_image_tar:
            load_image_cmd = f"""
        echo "üì¶ Loading base image from tar file... (this may take 2-3 minutes)"
        docker load -i /workspace/{base_image_tar}
        echo "‚úì Base image loaded into DinD daemon"
        """
        
        print('\n' + '=' * 70)
        print('STEP 2/5: Starting Docker-in-Docker and building image')
        print('=' * 70)
        
        # Create a unique Docker volume name for this build
        import uuid
        volume_name = f"docker-build-{uuid.uuid4().hex[:8]}"
        print(f'üìÅ Creating temporary Docker volume: {volume_name}')
        
        # Create Docker volume
        subprocess.check_output(['docker', 'volume', 'create', volume_name], stderr=subprocess.STDOUT)
        
        # Run Docker build inside Docker-in-Docker container with proper daemon startup
        docker_build_script = f"""
        set -e
        echo "üöÄ Starting Docker daemon..."
        # Start Docker daemon in background - use default /var/lib/docker location
        dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375 &
        # Wait for Docker daemon to start
        timeout=60
        while ! DOCKER_HOST=unix:///var/run/docker.sock docker version >/dev/null 2>&1; do
            sleep 2
            timeout=$((timeout - 2))
            if [ $timeout -le 0 ]; then
                echo "‚ùå Docker daemon failed to start"
                exit 1
            fi
        done
        echo "‚úì Docker daemon is ready"
        # Set Docker host for all subsequent commands
        export DOCKER_HOST=unix:///var/run/docker.sock
        {load_image_cmd}
        echo "üî® Building Docker image (with layer caching)..."
        # Build the image (removed --no-cache for speed)
        docker buildx build --platform linux/amd64 --progress=plain -t {dockerImagename} -f {dockerfilePath} ./
        echo "‚úì Docker image built successfully"
        echo "üíæ Saving image to tar file... (this may take 2-3 minutes)"
        # Save the image
        docker save -o /workspace/{baseFilename}.tar {dockerImagename}
        # Ensure the tar file has proper permissions
        chmod 644 /workspace/{baseFilename}.tar
        echo "‚úì Image saved to {baseFilename}.tar"
        """
        print('Running build in DinD container (showing live output)...\n')
        try:
            output = subprocess.check_output([
                'docker', 'run', '--rm', '--privileged',
                '--platform', 'linux/amd64',
                '-v', f"{volume_name}:/var/lib/docker",
                '-v', f"{os.getcwd()}:/workspace",
                '-w', '/workspace',
                docker_client_image,
                'sh', '-c', docker_build_script
            ], stderr=subprocess.STDOUT)
        finally:
            # Clean up Docker volume
            print(f'\nüóëÔ∏è  Cleaning up temporary Docker volume: {volume_name}')
            subprocess.run(['docker', 'volume', 'rm', '-f', volume_name], 
                         stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)  
        print(output.decode('utf-8'))
        
        step_time = time.time() - start_time
        print(f'\n‚è±Ô∏è  Build completed in {step_time:.1f} seconds')
        
        print('\n' + '=' * 70)
        print('STEP 3/5: Preparing documentation')
        print('=' * 70)
        # Copy documentation file with appropriate filename
        print(f'üìÑ Copying documentation to {baseFilename}.pdf...')
        try:
            shutil.copy(docsFile, baseFilename + '.pdf')
            print(f'‚úì Documentation copied')
        except IOError as e:
            print(f'‚ùå Error copying documentation: {e}')

        print('\n' + '=' * 70)
        print('STEP 4/5: Creating final package')
        print('=' * 70)
        # Zip into a package (using store mode for speed)
        print(f'üì¶ Packaging files into {baseFilename}.zip...')
        print('   (Using store mode - no compression for faster packaging)')
        output = subprocess.check_output([zipExe, 'a', '-tzip', '-mm=Deflate', baseFilename + '.zip', baseFilename + '.tar', baseFilename + '.pdf'], stderr=subprocess.STDOUT)
        print('‚úì Package created successfully')
        
        print('\n' + '=' * 70)
        print('STEP 5/5: Cleanup')
        print('=' * 70)
        # Optionally keep base_image_tar for next build
        keep_cache = os.getenv('KEEP_CACHE', 'true').lower() == 'true'
        if useLocalImage and base_image_tar and os.path.exists(base_image_tar):
            if keep_cache:
                print(f'üíæ Keeping {base_image_tar} for next build (set KEEP_CACHE=false to remove)')
            else:
                os.remove(base_image_tar)
                print(f'üóëÔ∏è  Removed temporary tar file: {base_image_tar}')
        
        total_time = time.time() - start_time
        print('\n' + '=' * 70)
        print(f'‚úÖ BUILD COMPLETED SUCCESSFULLY in {total_time:.1f} seconds ({total_time/60:.1f} minutes)')
        print('=' * 70)
        print(f'üì¶ Output: {baseFilename}.zip')
        if os.path.exists(baseFilename + '.zip'):
            size_bytes = os.path.getsize(baseFilename + '.zip')
            size_gb = size_bytes / (1024**3)
            print(f'üìä Size: {size_gb:.2f} GiB')
        print('=' * 70)

    except subprocess.CalledProcessError as e:
        # If the command returns a non-zero exit status, it will raise a CalledProcessError
        print('Command failed with return code:', e.returncode)
        print('Error output:\n' + e.output.decode('utf-8'))

